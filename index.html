<!--- Java script and HTML implementation fo the GUI ----------------------->
<!---- Autor: Hans N. Beck  (c) -------------------------------------------->


<!DOCTYPE html >
<html>
<head>
	<meta charset="UTF-8" />
	 <link rel="stylesheet" href="/web/bjstyles.css">

	<script src="/web/jquery-1.11.3.min.js"  type="text/javascript"></script>
	<script src="/web/tau-prolog.js" type="text/javascript"></script>
	<script src="/web/pengines.js" type="text/javascript"></script>
	<script src="/web/p5.min.js" type="text/javascript"></script>

	<script type="text/javascript">

		// the Prolog engines
		var pengine; 
		var session = pl.create(1000);

		// globals for Prolog communication
		var resList;
		var result; 

		// the objects, which are costumes
		var lights; 
		var aDesk; 
		var gameCanvas; 
		var deckCostume; 
		var cards; 
		
		// animation globals
		var pos = 1; // light counter
		var turnCounter = 0; 

		// useful constants
		const cWidth = 0; 
		const cHeight = 1; 
		const cMargin = 2; 
		const cX = 3;
		const cY = 4; 
		const cMidMargin = 3; 
		const canvasW = 800; 
		const canvasH = 350; 


		// geometric functions
		function cardFrame(W,H, deskFrame) {
			var frame = [1, 2, 4, 5, 6];
			frame[cWidth] = W/8; // width
			frame[cHeight] = frame[cWidth] * 1.5; // height
			frame[cMargin] = 5; // margin
			frame[cX] = deskFrame[cMargin] + frame[cMargin];
  			frame[cY] =	deskFrame[cMargin] + frame[cMargin]; 
  				
			return frame; 
		}

		function deskFrame(W,H) {
			var frame = [1, 2, 4, 5];
			frame[cWidth] = W; // width
			frame[cHeight] = H; // height
			frame[cMargin] = floor(W / 800*16); // margin
			frame[cMidMargin] = frame[cMargin]/2;  // position mid of border
			return frame; 
		}
	
		// Grafikobjekte
		class Lamp {
			constructor(x, y, c, frame) {
				this.color = c; 
				this.x = x; 
				this.y = y; 
				this.diameter = frame[cMargin]; 
				this.lumPhase = 0; 
			};
			
			luminate(pos){
				var value = this.fadeLuminance();
				var hVal = hue(this.color);
				var sVal = saturation(this.color);
				this.color = color(hVal, sVal, value);
			};

			fadeLuminance() {
				var lichtprofil = [30, 40, 50, 40, 30];
				var value = 20; 

				this.lumPhase += 1; 
				if ((this.lumPhase  >= 0) && (this.lumPhase < lichtprofil.length)) {
					value = lichtprofil[this.lumPhase];
				}
				else
				{
					this.lumPhase = 0; 
				}
				return value; 
			};

			draw() {
				noStroke(); 
				fill(this.color);
				circle(this.x,this.y,this.diameter);
			};
		}

		class Desk {
			constructor(frame) {
				var lampDia = frame[cMargin];
				colorMode(HSL, 360,100,100,1); 

  				let borderCol = color(35,79, 23);
  				let deskCol = color(135,50,21);
  
	  			noStroke(); 
	  			fill(borderCol);
	  			rect(0,0,frame[cWidth],frame[cHeight]);
	  			noStroke(); 
	  			fill(deskCol);
	  			rect(	lampDia,
	  					lampDia,
	  					frame[cWidth]-lampDia-lampDia,
	  					frame[cHeight]-lampDia-lampDia
	  				);
			}
		}

		class LampLine {
			constructor(frame) {
				var deskWidth = frame[cWidth];
				var deskHeight = frame[cHeight];
				var lampDia = frame[cMargin]; // lamps diameter is same as border thickness
				var firstLampX = frame[cMidMargin]; 
				var firstLampY = firstLampX; // Border has in every direction the same thickness
				var lastPosX; 
				var lastPosY; 

				this.lamps = [];

				colorMode(HSL, 360,100,100,1); 
				let col = color(60, 100, 20);

				// try alternative expressen: generate coodinates right down and mirror them
				for (var ix = firstLampX;  ix <= deskWidth; ix += lampDia)
				{
					this.lamps.push(new Lamp(ix, firstLampY, col, frame));
					lastPosX = ix; 
				}
				for (var iy = firstLampY-lampDia; iy <= deskHeight - lampDia; iy += lampDia)
				{
					this.lamps.push(new Lamp(lastPosX, iy, col, frame));
					lastPosY = iy; 
				}
				for (ix = lastPosX; ix >= firstLampX;  ix -= lampDia)
				{
					this.lamps.push(new Lamp(ix, firstLampY+(deskHeight-lampDia), col, frame));
				}
				for (iy = lastPosY; iy >= firstLampY-lampDia;  iy -= lampDia)
				{
					this.lamps.push(new Lamp(firstLampX, iy, col, frame));
					
				}
			}

			draw(posIn) {
				var loc = posIn; 
  				// Displays the image at its actual size at point (0,0)
	  			if (loc >= this.lamps.length) {loc = 0};
	  				for (var n = 0; n < 5; n++)
	  				{
	  					var index = loc - (n + 3);
	  					if (index>=this.lamps.length) { index = index -  this.lamps.length}
	  					if (index<0) { index = index + this.lamps.length}
	  					this.lamps[index].luminate(n);
	  					
	  				}
	  				
	  			for (var i = 0; i< this.lamps.length; i++)
	  			{
	  				this.lamps[i].draw();
	  			}
    			return loc; 
			}
		}

		class Costume {
			constructor(cardName, cardFrame, playerNo) {
				this.cardFrame = new Array(5);
				this.cardFrame[0] = cardFrame[0];
				this.cardFrame[1] = cardFrame[1];
				this.cardFrame[2] = cardFrame[2];
				this.cardFrame[3] = cardFrame[3];
				this.cardFrame[4] = cardFrame[4];
				this.img = loadImage('/graphics/'+cardName+'.png');
				//console.log('costume name is: ' + cardName);
				//console.log('costume cX ' + this.cardFrame[cX] + ' cy ' + this.cardFrame[cY]);
				this.owner = playerNo;  
			}
			draw() {
				image(this.img, 
  					this.cardFrame[cX], 
  					this.cardFrame[cY], 
  					this.cardFrame[cWidth],
  					this.cardFrame[cHeight]
  				);
			}
			move(counter){
				// only every 2. turn one next to the right
				var pos = floor(counter/2)+1;
				this.cardFrame[cX] =  this.cardFrame[cX] + pos * (this.cardFrame[cMargin] + 
																	this.cardFrame[cWidth]);
				switch (this.owner) {
					case 1: 
						break; 
					case 2:
						// Spieler 2 hat die zweite Reihe
						this.cardFrame[cY] =  this.cardFrame[cY] + 
												this.cardFrame[cMargin] + 
												this.cardFrame[cHeight];
						break; 
				}	
			}
		}

		//////////////// Processing code -> graphics ////////////////////

		// setup the geometric things
		function setup() {
			//frameRate(15);
			init_Prolog();

			// the main desk
			var aDeskFrame = deskFrame(canvasW, canvasH);
			// a Frame for the deck of cards. Its also a prototype for every cardframe
			var aDeckFrame = cardFrame(canvasW, canvasH, aDeskFrame); 
			// cardframe for one drawn card
			var aCardFrame = cardFrame(canvasW, canvasH, aDeskFrame); 
  		
  			cards = []; 
  			gameCanvas = createCanvas(canvasW, canvasH);
  			gameCanvas.parent('p1Container');
  			aDesk = new Desk(aDeskFrame);
  			deckCostume  = new Costume('backside', aCardFrame, 0);
  			lights = new LampLine(aDeskFrame); 
		}

		// processing main draw function
		function draw() {
			pos += 1; 
			pos = lights.draw(pos);
			deckCostume.draw(); 

  			for (var i = 0; i < cards.length; i++)
  			{
  				cards[i].draw();
  			}
  			
		}
 		
 		// interface Prolog to Graphics
 		function newCostume(name, playerNo) {
 			turnCounter += 1; 
 			//console.log('New Costume called with player ' + playerNo + 'turn ' + turnCounter);
 			var currentCostume = new Costume(name, deckCostume.cardFrame, playerNo);
 			currentCostume.move(turnCounter); 
 			cards.push(currentCostume);
 		}

 	
 		//////////////// Prolog Code //////////////////

 		// setup Prolog system
		function init_Prolog() {
			$.get("/web/webProlog.pl", function(data) {
				session.consult(data);
		 	});

			// Tau is ready, now pengine
			pengine = new Pengine({
				oncreate: handleCreate, 
				onsuccess: handleOutput,
				destroy: false
			}); 	

			
			// call the init of the game
			//pengine.ask('playGame(PA2, PP2, Msg)');
			console.log('Prolog Init done');
		}
		
		// here are the Pengine handle functions
		function handleCreate() {
			// init tau prolog
			session.query("init.");
			session.answer(printAnswer);

			// call the init of the game
			pengine.ask('playGame(PA2, PP2, Msg)');
		}
		// Pengine handle function for reveiving SWI Prolog answer
		function handleOutput(){
			// store the answer into global variable for later analysis
			// in future should be more intelligent. P1 P2 must not be there always
		
			resList = []; 
			for (x in this.data[0])
			{
				// properties must be lowercase later for Tau Prolog
				this.data[0][x.toLowerCase()] = this.data[0][x];
				this.data[0][x].delete;
				resList.push(x.toLowerCase());
			}
			result = this.data[0];
			console.log(result);
			
			session.query("takeResult(["+ resList.toString() + "], result, Term).");
			session.answer(printAnswer);
		}

		/////// Tau Prolog ///////

		// Callback needed for triggering and displaying answers of Tau prolog querys
		var printAnswer = function(answer){
			// Debug code
			//$("#Tauout").append(pl.format_answer(answer));
			//$("#Tauout").append("<br>");
			console.log('Tau answer:' + answer);
		}

		function sendPengine() {
			var query = $("#Tauhtml").text();
			console.log("Query will be: " + query);
			pengine.ask(query);
		}

	</script>


	<title> Demo game Black Jack </title>
	
</head>
<body>
	
	<div id="playarea">

		<h1>Demo game Black Jack</h1>
		</p>
		<h3>This simple game is intended as template for projects using SWI Prolog, its Pengines library and Tau-Prolog.</h3>
		
		<button type="button" id="btplay"  >Play Card</button> 
		<button type="button" id="btstop" >Stop</button>
		<p>
		<div id='p1Container'></div>	
		</p>
		<div id="pout"></div>
		<hr>
	</div>
	
	<!-- standard this section is invisible - only for debug -->

	<div id="testblock"> 
		<h4> Test / Debug area </h4>
		<p> The test below queries for a hard coded predicate .</p>

		 Output for Tau Prolog queries. Output is done via callback of the pl.answer function of Tau Prolog.
		 </p>
		 <div id="Tauout"></div>
		 </p>
		 <div id="Tauhtml">Tau terms</div>

	</div>
</p>
	
</body>
</html>